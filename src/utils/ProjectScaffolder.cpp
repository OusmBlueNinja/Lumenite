#include "ProjectScaffolder.h"
#include <filesystem>
#include <fstream>
#include <iostream>

namespace fs = std::filesystem;

#define COLOR_RESET   "\033[0m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_RED     "\033[31m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_CYAN    "\033[36m"
#define COLOR_BOLD    "\033[1m"

void ProjectScaffolder::log(const std::string &message, const std::string &prefix)
{
    std::string color = COLOR_GREEN;

    if (prefix == "[!] ")
        color = COLOR_YELLOW;
    else if (prefix == "[x] ")
        color = COLOR_RED;
    else if (prefix == "[*] ")
        color = COLOR_CYAN;

    std::cout << color << prefix << COLOR_RESET << message << '\n';
}


void ProjectScaffolder::createDir(const fs::path &path)
{
    fs::create_directories(path);
    log("Created: " + path.string());
}

void ProjectScaffolder::writeFile(const fs::path &path, const std::string &content)
{
    if (fs::exists(path)) {
        log("Skipped (already exists): \"" + path.string() + "\"", "[!] ");
    } else {
        std::ofstream file(path);
        if (file) file << content;
        log("Wrote: " + path.string());
    }
}

void ProjectScaffolder::createWorkspace(const std::string &name)
{
    fs::path root = fs::current_path() / name;

    if (fs::exists(root)) {
        log("Error: directory already exists: " + root.string(), "[x] ");
        return;
    }

    fs::create_directories(root);
    log("Initializing Lumenite project in: " + root.string(), "[*] ");

    // Main folders
    createDir(root / "app");
    createDir(root / "db");
    createDir(root / "templates");
    createDir(root / ".lumenite");
    createDir(root / "log");
    createDir(root / "vendor");

    // app/app.lua
    std::string appLua = R"(
-- app/app.lua
local safe = require("LumeniteSafe")

app:get("/", function(request)
    return app.render_template("template.html", {
        title = "Welcome to Lumenite",
        project_name = "{{project_name}}",
        content = "<p>This content was injected into the layout.</p>",
        timestamp = os.date("!%Y-%m-%d %H:%M:%S UTC")
    })
end)

app.after_request(function(request, response)
    response.headers["X-Powered-By"] = "Lumenite"
    return response
end)

app:template_filter("safe", function(input)
    return safe.escape(input)
end)

app:listen(8080)
)";

    size_t pos = appLua.find("{{project_name}}");
    if (pos != std::string::npos) {
        appLua.replace(pos, 16, name);
    }

    writeFile(root / "app" / "app.lua", appLua);


    // templates/template.html
    writeFile(root / "templates" / "template.html", R"(<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ title }}</title>
    <style>
        body { font-family: sans-serif; padding: 2rem; background: #f9f9f9; }
        header { font-size: 1.5rem; font-weight: bold; color: #333; }
        footer { margin-top: 2rem; font-size: 0.85rem; color: #777; }
    </style>
</head>
<body>
    <header>{{ project_name }}</header>
    <main>
        <h2>{{ title }}</h2>
        {{{ content }}}
    </main>
    <footer>
        <em>Rendered at {{ timestamp }}</em>
    </footer>
</body>
</html>
)");


    // .lumenite/__syntax__.lua (IntelliSense stub)
    writeFile(root / ".lumenite" / "__syntax__.lua", R"(

---@meta

--[[----------------------------------------------------------------------------
  This file provides IntelliSense and type annotations for the Lumenite web framework.

  ⚠️ DO NOT EDIT THIS FILE MANUALLY.
  It is automatically generated and used by Lua language servers (such as EmmyLua / LuaLS)
  to enable autocompletion, documentation, and static type checking in Lumenite-based apps.

  Any manual changes will be overwritten during regeneration or update.
------------------------------------------------------------------------------]]

---@alias Headers table<string, string>
---@alias RouteHandler fun(req: Request, ...: string): string|Response|table



---@class SendFileOptions
---@field as_attachment? boolean
---@field download_name? string
---@field content_type? string
---@field status? integer
---@field headers? Headers

---@class Request
---@field method string
---@field path string
---@field headers Headers
---@field query table<string, string|string[]>
---@field form table<string, string|string[]>
---@field body string
---@field remote_ip string

---@class Response
---@field status integer
---@field headers Headers
---@field body string

---@class App
local app = {}

---@param path string
---@param handler RouteHandler
function app:get(path, handler) end

---@param path string
---@param handler RouteHandler
function app:post(path, handler) end

---@param path string
---@param handler RouteHandler
function app:put(path, handler) end

---@param path string
---@param handler RouteHandler
function app:delete(path, handler) end

---@param key string
---@return string
function app.session_get(key) end

---@param key string
---@param value string
function app.session_set(key, value) end

---@param name string
---@param fn fun(input: string): string
function app:template_filter(name, fn) end

---@param filename string
---@param context table
---@return string
function app.render_template(filename, context) end

---@param template_string string
---@param context table
---@return string
function app.render_template_string(template_string, context) end

---@param path string
---@param options? SendFileOptions
---@return Response
function app.send_file(path, options) end

---@param table table
---@return Response
function app.jsonify(table) end

---@param json string
---@return table
function app.json(json) end

---@param json string
---@return table
function app.from_json(json) end

---@param fn fun(req: Request): Response|nil
function app.before_request(fn) end

---@param fn fun(req: Request, res: Response): Response|nil
function app.after_request(fn) end

---@param url string
---@return table
function app.http_get(url) end

---@overload fun(status: integer)
---@param status integer
---@param message? string
function app.abort(status, message) end

---@param port integer
function app:listen(port) end

---@type App
_G.app = app

return app


)");

    // README.md
    writeFile(root / "README.md",
              "# " + name +
              "\n\nMade by [Lumenite](https://github.com/OusmBlueNinja/Lumenite)");

    // .gitignore
    writeFile(root / ".gitignore", R"(
*.db
*.log
.vscode/
build/
)");

    log("Created Lumenite workspace: " + name);
}
